/*
 * Copyright (C) 2014  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  @file
 *  domain browser interface
 */


#ifndef DOMAIN_BROWSER_IDL_
#define DOMAIN_BROWSER_IDL_

module Registry {
module DomainBrowser {

    /**
     * Internal server error.
     * Unexpected failure, requires maintenance.
     */
    exception INTERNAL_SERVER_ERROR { };
    /**
     * Contact of the user requesting the service was not found.
     * The contact could have been deleted or set into inappropriate state.
     */
    exception USER_NOT_EXISTS { };
    /**
     * Requested object was not found.
     * Requested object could have been deleted or set into inappropriate state.
     */
    exception OBJECT_NOT_EXISTS { };
    /**
     * Incorrect usage of the service.
     * Unexpected input data. This should not happen, probably result of bad interface design.
     */
    exception INCORRECT_USAGE { };
    /**
     * Access to requested information is forbidden.
     */
    exception ACCESS_DENIED { };
    /**
     * Requested object does not allow update.
     * Requested object has a status that does not allow update.
     */
    exception OBJECT_BLOCKED { };

    /**
     * Invalid contacts.
     * Unable to merge contacts.
     */
    exception INVALID_CONTACTS { };

    /**
     * arbitrary date
     */
    typedef string Date;

    /**
     * nullable date
     */
    valuetype NullableDate Date;
    
    /**
     * arbitrary timestamp
     */
    typedef string DateTime;

    /**
     * nullable timestamp
     */
    valuetype NullableDateTime DateTime;

    /**
     * nullable database id
     */
    valuetype NullableULongLong unsigned long long;

    /**
     * Registry object id, handle and name data.
     */
    struct RegistryReference
    {
        unsigned long long id;
        string handle;
        string name;
    };
    typedef sequence<RegistryReference> RegistryReferenceSeq;

    /**
     * Object id sequence.
     */
    typedef sequence<unsigned long long> ObjectIdSeq;
    /**
     * Indicates whether user contact can get public or private data of given object
     */
    enum DataAccessLevel
    {
        PUBLIC_DATA,
        PRIVATE_DATA
    };

    struct RegistrarDetail {
        unsigned long long id;
        string handle;
        string name;
        string phone;
        string fax;
        string url;/**< web address of the registrar */
        string address;/**< postal address of the registrar */
    };

    /**
     * object state code sequence
     */
    typedef sequence<string> StateCodeSequence;
    
    struct DomainDetail {
        unsigned long long id;
        string fqdn;
        string roid;
        RegistryReference registrar;
        DateTime create_time; /**< timestamp of creation*/
        NullableDateTime update_time; /**< timestamp of update*/
        string auth_info;/**< password for transfer */
        RegistryReference registrant;
        Date expiration_date; /**< date of domain expiration*/
        NullableDate val_ex_date;/**< the expiration date of the ENUM domain validation */
        boolean publish;/**< flag for publishing ENUM number and associated contact in public directory */
        boolean is_enum;/**<  is ENUM domain */
        RegistryReference nsset;
        RegistryReference keyset;
        RegistryReferenceSeq admins;
        StateCodeSequence state_codes;/**< object states names from db. table enum_object_states */
    };

    /**
     * Contact fields disclose data.
     */
    struct ContactDiscloseFlags {
        boolean name;
        boolean organization;
        boolean email;
        boolean address;
        boolean telephone;
        boolean fax;
        boolean ident;
        boolean vat;
        boolean notify_email;
    };

    /**
     * Contact disclose flags to be set.
     */
    struct UpdateContactDiscloseFlags {
        boolean email;
        boolean address;
        boolean telephone;
        boolean fax;
        boolean ident;
        boolean vat;
        boolean notify_email;
    };

    struct ContactDetail {
        unsigned long long id;
        string handle;
        string roid;/**< registry object identifier of the contact */
        RegistryReference registrar;
        DateTime create_time;
        NullableDateTime transfer_time;
        NullableDateTime update_time;
        string auth_info;/**< password for transfer */
        string name;
        string organization;
        string street1;
        string street2;
        string street3;
        string province;
        string postalcode;
        string city;
        string country;
        string telephone;
        string fax;
        string email;
        string notify_email;
        string ssn;/**< unambiguous identification number e.g. social security number, identity card number, date of birth */
        string ssn_type;/**< type of identification */
        string vat;/**< taxpayer identification number */
        ContactDiscloseFlags disclose_flags;
        StateCodeSequence state_codes;/**< contact states names*/
    };

    /**
     * ip address sequence
     */
    typedef sequence<string> IPAddrSequence;
    
    struct DNSHost
    {
        string fqdn; /**< fully qualified name of the nameserver host*/
        IPAddrSequence inet; /**< list of IPv4 or IPv6 addresses of the nameserver host*/
    };

    struct NSSetDetail {
        unsigned long long id;
        string handle;
        string roid;/**< registry object identifier of nsset */
        RegistryReference registrar;
        DateTime create_time;
        NullableDateTime transfer_time;
        NullableDateTime update_time;
        RegistryReference create_registrar;
        RegistryReference update_registrar;
        string auth_info;/**< password for transfer */
        RegistryReferenceSeq admins;
        sequence<DNSHost> hosts;/**< nsset DNS hosts */
        StateCodeSequence state_codes;/**< nsset states names */
        short report_level;/**< nsset level of technical checks */
    };

    /**
     * Type for an element of list of DS records to be removed, obsolete.
     */
    struct DSRecord
    {
        long key_tag;
        long alg;
        long digest_type;
        string digest;
        long max_sig_life;
    };

    struct DNSKey
    {
        unsigned short flags;
        unsigned short protocol;/**< only valid value is 3*/
        unsigned short alg;/**< the algorithm field identifies the public key's cryptographic algorithm, values can be found in RFC 4034 Apendix A.1. */
        string         key;/**< the public key field in base64 encoding */
    };


    struct KeysetDetail {
        unsigned long long id;
        string handle;
        string roid;/**< registry object identifier of keyset */
        RegistryReference registrar;
        DateTime create_time;
        NullableDateTime transfer_time;
        NullableDateTime update_time;
        RegistryReference create_registrar;
        RegistryReference update_registrar;
        string auth_info;/**< password for transfer */
        RegistryReferenceSeq admins;
        sequence<DSRecord> dsrecords;/**< not set by implementation, to be removed */
        sequence<DNSKey> dnskeys;
        StateCodeSequence state_codes;/**< keyset states names */
    };

    /**
     * Type of blocking to be applied
     */
    enum ObjectBlockType {
        BLOCK_TRANSFER,
        UNBLOCK_TRANSFER,
        BLOCK_TRANSFER_AND_UPDATE,
        UNBLOCK_TRANSFER_AND_UPDATE
    };

    /**
     * Next domain state data.
     */
    struct NextDomainState
    {
        string state_code; /**< next state code */
        Date state_date; /**< next state date */
    };

    /**
     * optional next domain state
     */
    valuetype NullableNextDomainState NextDomainState;

    /**
     * element of DomainList
     */
    struct DomainListData
    {
        unsigned long long id;/**< id of the domain */
        string fqdn;/**< fully qualified domain name */
        unsigned long long external_importance;/**<  bitwise OR of importance values of states with external flag or next higher power of 2 value if bitwise OR is zero */
        NullableNextDomainState next_state;/**< next state of the domain (if any) according to current date and expiration date, outzone date and delete date of the domain */
        boolean have_keyset; /**< domain have keyset flag */
        string user_role; /**< domainbrowser user relation to the domain (holder/admin/'') */
        string registrar_handle; /**< domain registrar handle*/
        string registrar_name; /**< domain registrar name*/
        StateCodeSequence state_code;/**< domain states*/
        boolean is_server_blocked; /**< whether domain have serverBlocked state */
    };
    
    /**
     * domain list output
     */
    typedef sequence<DomainListData> DomainList;
    
    /**
     * element of NssetList
     */
    struct NssetListData
    {
        unsigned long long id;/**< id of the nsset */
        string handle;/**< nsset handle */
        unsigned long long domain_count;/**<  number of domains using this nsset */
        string registrar_handle; /**< nsset registrar handle*/
        string registrar_name; /**< nsset registrar name*/
        unsigned long long external_importance;/**<  bitwise OR of importance values of states with external flag or next higher power of 2 value if bitwise OR is zero */
        StateCodeSequence state_code;/**< nsset states*/
        boolean is_server_blocked; /**< whether nsset have serverBlocked state */
    };
    
    /**
     * nsset list output
     */
    typedef sequence<NssetListData> NssetList;

    /**
     * element of KeysetList
     */
    struct KeysetListData
    {
        unsigned long long id;/**< id of the keyset */
        string handle;/**< keyset handle */
        unsigned long long domain_count;/**<  number of domains using this keyset */
        string registrar_handle; /**< keyset registrar handle*/
        string registrar_name; /**< keyset registrar name*/
        unsigned long long external_importance;/**<  bitwise OR of importance values of states with external flag or next higher power of 2 value if bitwise OR is zero */
        StateCodeSequence state_code;/**< keyset states*/
        boolean is_server_blocked; /**< whether keyset have serverBlocked state*/
    };
    
    /**
     * keyset list output
     */
    typedef sequence<KeysetListData> KeysetList;

    /**
     * element of MergeContactCandidateList
     */
    struct MergeContactCandidateData
    {
        unsigned long long id;/**< id of the contact */
        string handle;/**< contact handle */
        unsigned long long domain_count;/**<  number of domains linked with this contact */
        unsigned long long nsset_count;/**<  number of nssets linked with this contact */
        unsigned long long keyset_count;/**<  number of keysets linked with this contact */
        string registrar_handle; /**< contact registrar handle*/
        string registrar_name; /**< contact registrar name*/
    };
    
    /**
     * merge contact candidate list
     */
    typedef sequence<MergeContactCandidateData> MergeContactCandidateList;
    
    /**
     * sequence of object handles refused by setObjectBlockStatus call
     */
    typedef sequence<string> RefusedObjectHandleSequence;
    
    /**
     * object state description
     */
     struct StatusDesc
     {
         string state_code;/**< state name */
         string state_desc;/**< state description in some language */
     };
     
    /**
     * sequence of object state description
     */
    typedef sequence<StatusDesc> StatusDescList;
    
    interface Server {

        /**
         * Gets database id of the contact.
         * @param handle is object registry handle of the contact
         * @return contact database id
         * @throw @ref OBJECT_NOT_EXISTS if contact not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        unsigned long long getContactId(
            in string handle
        ) raises (INTERNAL_SERVER_ERROR, OBJECT_NOT_EXISTS);

        /**
         * Get list of domains registered or administered by user contact or contact.
         * @param user_contact_id contains database id of the user contact
         * @param contact_id if set list domains linked to contact with given id regardless of user contact relation to listed domains
         * @param offset contains list offset for pagination
         * @param limit_exceeded output flag means having more data for list than configured list limit
         * @return list of domain data
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if contact_id is set and not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        DomainList getDomainList(
            in unsigned long long user_contact_id,
            in NullableULongLong contact_id,
            in unsigned long offset,
            out boolean limit_exceeded
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, OBJECT_NOT_EXISTS);

        /**
         * Get list of nssets administered by user contact.
         * @param user_contact_id contains database id of the user contact
         * @param contact_id if set list nssets linked to contact with given id regardless of user contact relation to listed nssets
         * @param offset contains list offset for pagination
         * @param limit_exceeded output flag means having more data for list than configured list limit
         * @return list of nsset data
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if contact_id is set and not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        NssetList getNssetList(
            in unsigned long long user_contact_id,
            in NullableULongLong contact_id,
            in unsigned long offset,
            out boolean limit_exceeded
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, OBJECT_NOT_EXISTS);

        /**
         * Get list of keysets administered by user contact.
         * @param user_contact_id contains database id of the user contact
         * @param contact_id if set list keysets linked to contact with given id regardless of user contact relation to listed keysets
         * @param offset contains list offset for pagination
         * @param limit_exceeded output flag means having more data for list than configured list limit
         * @return list of keyset data
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if contact_id is set and not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        KeysetList getKeysetList(
            in unsigned long long user_contact_id,
            in NullableULongLong contact_id,
            in unsigned long offset,
            out boolean limit_exceeded
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, OBJECT_NOT_EXISTS);

        /**
         * Get list of domains linked to given keyset.
         * @param contact_id contains database id of the user contact
         * @param keyset_id list domains linked to keyset with given id regardless of user contact relation to listed domains
         * @param offset contains list offset for pagination
         * @param limit_exceeded output flag means having more data for list than configured list limit
         * @return list of domain data
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref ACCESS_DENIED if keyset not administered by user contact or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        DomainList getDomainsForKeyset(
            in unsigned long long contact_id,
            in unsigned long long keyset_id,
            in unsigned long offset,
            out boolean limit_exceeded
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, ACCESS_DENIED);

        /**
         * Get list of domains linked to given nsset.
         * @param contact_id contains database id of the user contact
         * @param nsset_id list domains linked to nsset with given id regardless of user contact relation to listed domains
         * @param offset contains list offset for pagination
         * @param limit_exceeded output flag means having more data for list than configured list limit
         * @return list of domain data
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref ACCESS_DENIED if nsset not administered by user contact or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        DomainList getDomainsForNsset(
            in unsigned long long contact_id,
            in unsigned long long nsset_id,
            in unsigned long offset,
            out boolean limit_exceeded
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, ACCESS_DENIED);

        /**
         * Returns contact detail.
         * @param contact_id contains database id of the user contact
         * @param detail_id contains database id of the contact whose detail is requested
         * @param auth_result output is PUBLIC_DATA if user contact is different from requested contact then transfer password is hidden, PRIVATE_DATA if user contact is the same as requested contact then transfer password is disclosed
         * @return contact detail data @ref ContactDetail
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if contact not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        ContactDetail getContactDetail(
            in unsigned long long contact_id,
            in unsigned long long detail_id,
            out DataAccessLevel auth_result
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, OBJECT_NOT_EXISTS);

        /**
         * Returns nsset detail.
         * @param contact_id contains database id of the user contact
         * @param nsset_id contains database id of the nsset whose detail is requested
         * @param auth_result output is PUBLIC_DATA if user contact is not admin of requested nsset then transfer password is hidden, PRIVATE_DATA if user contact is admin of the requested nsset then transfer password is disclosed
         * @return nsset detail data @ref NSSetDetail
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if nsset not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        NSSetDetail getNssetDetail(
            in unsigned long long contact_id,
            in unsigned long long nsset_id,
            out DataAccessLevel auth_result
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, OBJECT_NOT_EXISTS);

        /**
         * Returns domain detail.
         * @param contact_id contains database id of the user contact
         * @param domain_id contains database id of the domain whose detail is requested
         * @param auth_result output is PUBLIC_DATA if user contact is not admin or owner of requested domain then transfer password is hidden, PRIVATE_DATA if user contact is admin or owner of the requested domain then transfer password is disclosed
         * @return domain detail data @ref DomainDetail
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if domain not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        DomainDetail getDomainDetail(
            in unsigned long long contact_id,
            in unsigned long long domain_id,
            out DataAccessLevel auth_result
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, OBJECT_NOT_EXISTS);

        /**
         * Returns keyset detail.
         * @param contact_id contains database id of the user contact
         * @param keyset_id contains database id of the keyset whose detail is requested
         * @param auth_result output is PUBLIC_DATA if user contact is not admin of requested keyset then transfer password is hidden, PRIVATE_DATA if user contact is admin of the requested keyset then transfer password is disclosed
         * @return keyset detail data @ref KeysetDetail
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if keyset not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        KeysetDetail getKeysetDetail(
            in unsigned long long contact_id,
            in unsigned long long keyset_id,
            out DataAccessLevel auth_result
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, OBJECT_NOT_EXISTS);

        /**
         * Returns registrar detail.
         * @param contact_id contains database id of the user contact
         * @param handle contains object registry handle of the registrar whose detail is requested
         * @return registrar detail data @ref RegistrarDetail
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if registrar not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        RegistrarDetail getRegistrarDetail(
            in unsigned long long contact_id,
            in string handle
        ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, OBJECT_NOT_EXISTS);

        /**
         * Sets contact disclose flags.
         * @param contact_id contains database id of the contact
         * @param flags contains contact disclose flags
         * @param request_id is id of the new entry in log_entry database table
         * @return true if disclose flags were set, false if not or exception in case of failure
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref INCORRECT_USAGE when organization is set it's not allowed to hide address, @ref ACCESS_DENIED if contact not identified or validated, @ref OBJECT_BLOCKED if contact is blocked or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        boolean setContactDiscloseFlags(
            in unsigned long long contact_id,
            in UpdateContactDiscloseFlags flags,
            in unsigned long long request_id
        ) raises (INTERNAL_SERVER_ERROR, INCORRECT_USAGE, USER_NOT_EXISTS, ACCESS_DENIED, OBJECT_BLOCKED);

        /**
         * Sets contact transfer password.
         * @param contact_id contains database id of the user contact
         * @param objtype is "contact"
         * @param objref_id contains database id of the contact to be modified
         * @param auth_info is new transfer password
         * @param request_id is id of the new entry in log_entry database table
         * @return true if authinfo were set, false if not or exception in case of failure
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref ACCESS_DENIED if user contact is different from contact or not identified or validated, @ref INCORRECT_USAGE if new transfer password is longer than 300 characters or objtype is not "contact" @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        boolean setAuthInfo(
            in unsigned long long contact_id,
            in string objtype,
            in unsigned long long objref_id,
            in string auth_info,
            in unsigned long long request_id
        ) raises (INTERNAL_SERVER_ERROR, INCORRECT_USAGE, USER_NOT_EXISTS, ACCESS_DENIED);

        /**
         * Sets blocking state of the object.
         * @param contact_id contains database id of the user contact
         * @param objtype type of the objects to be set: domain , nsset or keyset
         * @param objects list of database ids of the objects to be set
         * @param block is type of blocking to be applied
         * @param change_prohibited is output list of object handles of objects with SERVER_BLOCKED state or objects attempted to be partially unblocked (which is now forbidden)
         * @return false if no object blocked, true if not or exception in case of failure
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found, @ref OBJECT_NOT_EXISTS if object not found, @ref ACCESS_DENIED if user contact is not validated, @ref INCORRECT_USAGE if objtype not found or objtype is "contact" or objects list is longer then 500 elements or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        boolean setObjectBlockStatus(
            in unsigned long long contact_id,
            in string objtype,
            in ObjectIdSeq objects,
            in ObjectBlockType block,
            out RefusedObjectHandleSequence change_prohibited
        ) raises (INTERNAL_SERVER_ERROR, INCORRECT_USAGE, USER_NOT_EXISTS, OBJECT_NOT_EXISTS, ACCESS_DENIED);

        /**
         * Get descriptions of public states.
         * @param lang contains language for state description "EN" or "CS"
         * @return list of state descriptions
         * @throw @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        StatusDescList getPublicStatusDesc(
                in string lang
            ) raises (INTERNAL_SERVER_ERROR);

        /**
         * Get list of contacts mergeable to user contact.
         * @param contact_id contains database id of the user contact
         * @param offset contains list offset for pagination
         * @param limit_exceeded output flag means having more data for list than configured list limit
         * @return list of merge contact candidates
         * @throw @ref USER_NOT_EXISTS if user contact not in mojeid or not found or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        MergeContactCandidateList getMergeContactCandidateList(
                in unsigned long long contact_id,
                in unsigned long offset,
                out boolean limit_exceeded
            ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS);

        /**
         * Merge contact list to destination contact
         * @param dst_contact_id id of destination contact
         * @param src_contact_id_list id list of source contacts
         * @param request_id is id of the new entry in log_entry database table
         * @throw @ref USER_NOT_EXISTS if destination contact not in mojeid or not found, @ref INVALID_CONTACTS if merge fails or @ref INTERNAL_SERVER_ERROR in case of failure.
         */
        void mergeContacts(
                in unsigned long long dst_contact_id,
                in ObjectIdSeq  src_contact_id_list,
                in unsigned long long request_id
            ) raises (INTERNAL_SERVER_ERROR, USER_NOT_EXISTS, INVALID_CONTACTS);

    };
};
};

#endif

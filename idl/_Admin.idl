#include "Filters.idl"
#include "_Registry.idl"
// TEMP: XXX forward declaration of PageTable
//       for returning new type from Session::getPageTable()
//       method (will be removed when using only Registry module)
module Registry {
  interface PageTable;

  module Registrar
  {
      module Certification
      {
          interface Manager;
      };
      module Group
      {
          interface Manager;
      };
  };
};

module ccReg {
  
  /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  ///          User management
  /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  /// Negative permission
  typedef string NPermission;

  interface User {
    attribute TID id;
    attribute string username;
    attribute string firstname;
    attribute string surname;
    boolean hasNPermission(in NPermission np);
  };

  /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  ///          Table management
  /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  /// One row of Table
  typedef sequence<string> TableRow;

  /// Table for data
  interface Table : Filters::Table {
    enum ColumnType {
       CT_REGISTRAR_HANDLE,
       CT_CONTACT_HANDLE,
       CT_DOMAIN_HANDLE,
       CT_NSSET_HANDLE,
       CT_KEYSET_HANDLE,
       CT_FILE_ID,
       CT_DATE,
       CT_TIME,
       CT_OTHER
    };
    struct ColumnDesc {
       string name;
       ColumnType type;
    };
    typedef sequence<ColumnDesc> ColumnHeaders;
    /// Exception for accessing invalid row
    exception INVALID_ROW {};
    /// Number of rows in table
    readonly attribute short numRows;
    /// Number of columns in table
    readonly attribute short numColumns;
    /// Real size of result of this filter
    readonly attribute unsigned long long resultSize;
    /// Return descriptions of all columns
    ColumnHeaders getColumnHeaders();
    /// Return ona row of string representation of data in table
    TableRow getRow(in unsigned short row) raises (INVALID_ROW);
    /// Sort data by column index
    void sortByColumn(in short column, in boolean dir);
    /// Return sorted by column index; -1 mean sorted by ID
    void getSortedBy(out short column, out boolean dir);
    /// Output data in CSV format
    string outputCSV();
    /// Return filter
    /// readonly attribute Filter aFilter;
    /// Return id of record at index
    TID getRowId(in unsigned short pageRow) raises (INVALID_ROW);
  };
  
  /// Table divided into pages
  interface PageTable : Table {
    /// Exception for accessing invalid page
    exception INVALID_PAGE {};
    /// Size of one page
    attribute short pageSize;
    /// Current page index
    readonly attribute short page;
    /// Set current page
    void setPage(in short page) raises (INVALID_PAGE);
    /// Set offset for db query
    void setOffset(in long offset);
    /// Set limit (max number of rows)
    void setLimit(in long limit);
    /// Start row of current page
    readonly attribute short start;
    /// Number of pages
    readonly attribute short numPages;
    /// Exact size of one page (always <= pageSize)
    readonly attribute short numPageRows;
    /// Type of filter applied on page table
    readonly attribute FilterType filter;
    /// Return row by index in page
    TableRow getPageRow(in short pageRow) raises (INVALID_ROW);
    /// Return id of record at index
    TID getPageRowId(in short pageRow) raises (INVALID_ROW);
    /// Return true if row result size is limited
    boolean numRowsOverLimit();
  };

  /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  ///          Filter management
  /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


  /// Filter for common registry object
  interface RegObjectFilter : Registry::FilterBase {
    /// Those made by specific registrar
    attribute TID registrar;    
    /// Those made by specific registrar byt handle
    attribute string registrarHandle;
    /// Those created by specific registrar
    attribute TID createRegistrar;    
    /// Those created by specific registrar byt handle
    attribute string createRegistrarHandle;
    /// Those updated by specific registrar
    attribute TID updateRegistrar;    
    /// Those updated by specific registrar byt handle
    attribute string updateRegistrarHandle;
    /// Interval of crDate
    attribute DateInterval crDate;
    /// Interval of trDate
    attribute DateInterval trDate;
    /// Interval of upDate
    attribute DateInterval upDate;
    /// Search in status - 'and' operator between values
    attribute Registry::ObjectStatusSeq status;
  };

  /// Filter for EPPActions
  interface EPPActionsFilter : Registry::FilterBase {
    /// Result classification type
    enum ResultType {
      RT_FAIL, ///< result >= 2000 or no result code at all
      RT_OK    ///< result < 2000
    };
    /// Those made by specific registrar
    attribute TID registrar;
    /// Those made by specific registrar byt handle
    attribute string registrarHandle;
    /// Those of specific type
    attribute Registry::EPPActionType type;
    /// Those refefing to object with this handle
    attribute string handle;
    /// Those having substring in xml
    attribute string xml;
    /// Those with this result code
    attribute short result;
    /// Those having proper result classification
    attribute ResultType resultClass;
    /// Those processed at this date interval
    attribute DateTimeInterval time;
    /// Those with specified clTRID
    attribute string clTRID;
    /// Those with specified svTRID
    attribute string svTRID;
  };
  
  module AuthInfoRequest {
    /// Type of AuthInfo request
    enum RequestType 
    {
      RT_IGNORE, ///< For filter ignoring
      RT_EPP, ///< Request was created by registrar through EPP
      RT_AUTO_PIF, ///< Request for automatic answer created through PIF
      RT_EMAIL_PIF, ///< Request waiting for autorization by signed email
      RT_POST_PIF ///< Request waiting for autorization by checked letter
    };
    /// Status of AuthInfo request 
    enum RequestStatus {
      RS_IGNORE, ///< For filter ignoring
      RS_NEW, ///< Unresolved request
      RS_ANSWERED, ///< Answered request
      RS_INVALID ///< Request closed as invalid
    } ;
    /// Type of object queried in AuthInfo request
    enum ObjectType {
      OT_IGNORE, ///< For filter ignoring
      OT_DOMAIN, ///< Request for authinfo in domain object
      OT_CONTACT, ///< Request for authinfo in contact object
      OT_NSSET, ///< Request for authinfo in nsset object
      OT_KEYSET ///< Request for authinfo in keyset object
    } ;
    /// Filter for selection of set of AuthInfo requests
    interface Filter : Registry::FilterBase {
      attribute TID id; ///< filter for id
      attribute string handle; ///< filter for surveyed object handle
      attribute RequestStatus status; ///< filter for request status
      attribute RequestType type; ///< filter for request type
      attribute DateTimeInterval crTime; ///< filter for create time interval
      attribute DateTimeInterval closeTime; ///< filter for close time interval
      attribute string reason; ///< filter in reason specified in PIF
      attribute string svTRID; ///< filter for EPP action svTRID
      attribute string email; ///< filter for email specified in PIF
    };
    struct Detail {
      TID id; ///< request id
      string handle; ///< surveyed object handle
      RequestStatus status; ///< request status
      RequestType type; ///< request type
      string crTime; ///< time of creation of request
      string closeTime; ///< time of request resolution
      string reason; ///< reason provided through PIF
      string svTRID; ///< EPP action id when created by registrar
      string email; ///< email provided through PIF
      long answerEmailId; ///< id of email with request answer
      ObjectType oType; ///< type of surveyed object
      TID objectId; ///< id of surveyed object
      string registrar; ///< registrar initiating request through EPP
    }; 
  };

  module Mailing {
    /// Filter for selection of set of mails
    interface Filter : Registry::FilterBase {
      attribute TID id; ///< filter for id 
      attribute long status; ///< filter for status (-1=ignore)
      attribute string handle; ///< filter for asociated handle
      attribute string attachment; ///< filter for attachement id
      attribute string fulltext; ///< filter for fulltext in email
      attribute unsigned short type; ///< filter for email type
      attribute DateTimeInterval createTime; ///< filter for create time interval
    };
    typedef sequence<TID> AttachmentSeq;
    /// Email detail
    struct Detail {
      TID id; ///< unique mail id (number before dot in message-id header)
      string createTime; ///< time of inserting record into db
      string modTime;///< date of last modification of status 
      long status; ///< status (0 = OK, otherwise sendamail return status)
      unsigned short type; ///< type
      string content; ///< complete email content without binary attachements
      Lists handles; ///< list of assocciated emails
      AttachmentSeq attachments; ///< names of binary attachements
    };
  };

  typedef string Money;
  module Invoicing {
    struct Payment {
      TID id;
      string number;
      Money price;
      Money balance;
    };
    typedef sequence<Payment> PaymentList;
    struct Action {
      TID objectId;
      string objectName;
      string actionTime;
      string exDate;
      unsigned short actionType;
      unsigned short unitsCount;
      Money pricePerUnit;
      Money price;
    };
    typedef sequence<Action> ActionList;
    enum InvoiceType {
      IT_ADVANCE,
      IT_ACCOUNT,
      IT_NONE //< for disabling filter
    };
    struct Invoice {
      TID id;
      TID zone;
      string crTime;
      string taxDate;
      string fromDate;
      string toDate;
      InvoiceType type;
      string number;
      TID registrarId;
      string registrarHandle;
      Money credit;
      Money price;
      unsigned short vatRate;
      Money total;
      Money totalVAT;
      string varSymbol;
      TID filePDF;
      TID fileXML;
      PaymentList payments;
      ActionList actions;
    };
    interface Filter :  Registry::FilterBase {
      attribute TID id;
      attribute string number;
      attribute DateInterval crDate;
      attribute TID registrarId;
      attribute string registrarHandle;
      attribute TID zone;
      attribute InvoiceType type;
      attribute string varSymbol;
      attribute DateInterval taxDate;
      attribute string objectName;
      attribute TID objectId;
      attribute string advanceNumber;
    };
  };
  
  /// Access structure
  struct EPPAccess {
    string password; ///< epp login password
    string md5Cert; ///< md5 of certificate
  };
  
  /// List of access structures
  typedef sequence<EPPAccess> EPPAccessSeq;
  
  ///Zone access
  struct ZoneAccess
  {
      ccReg::TID id; ///record id
      string name; ///zone name
      DateType fromDate;  ///start of registrar's access to zone
      DateType toDate; ///end of registrar's access to zone
  };//struct ZoneAccess

  /// List of zone structures
  typedef sequence<ZoneAccess> ZoneAccessSeq;

  /// Registrar detail structure
  struct Registrar {
    TID id; ///< registrar ID
    string ico;
    string dic;
    string varSymb;
    boolean vat;
    string handle; ///< registrar identification
    string name; ///< registrar name
    string organization; ///< organization name
    string street1; ///< address part 1
    string street2; ///< address part 2
    string street3; ///< address part 3
    string city; ///< city of registrar headquaters
    string stateorprovince; ///< address part
    string postalcode; ///< address part
    Registry::CountryCode country; ///< country code
    string telephone; ///< phne number
    string fax; ///< fax number
    string email; ///< contact email
    string url; ///< URL
    Money credit; ///< actual credit
    EPPAccessSeq access; ///< list of epp access data
    ZoneAccessSeq zones; ///< list of active registrar's zones
    boolean hidden; ///< hidden in PIF
  };

  struct EPPAction {
    TID id; ///< id of action
    string time; /// < processing time
    string xml; ///< xml of request
    string xml_out; ///< xml of response
    string type; ///< typename of request
    string objectHandle; ///< handle of major object
    string registrarHandle; ///< handle of registrar processiong request
    short result; ///< result code
    string clTRID; ///< token provided by registrar
    string svTRID; ///< token attached by server
  };
 

  typedef sequence<string> ContactHandleSeq;
  struct DomainDetail {
     TID id;
     string fqdn;
     string roid;
     string registrarHandle;
     string createDate;
     string transferDate;
     string updateDate;
     string createRegistrarHandle;
     string updateRegistrarHandle;
     string authInfo;
     string registrantHandle;
     string expirationDate;
     string valExDate;
     boolean publish; 
     string nssetHandle;
     string keysetHandle;
     ContactHandleSeq admins;
     ContactHandleSeq temps;
     Registry::ObjectStatusSeq statusList;
  };

  struct ContactDetail {
     TID id;
     string handle;
     string roid;
     string registrarHandle;
     string createDate;
     string transferDate;
     string updateDate;
     string createRegistrarHandle;
     string updateRegistrarHandle;
     string authInfo;
     string name;
     string organization;
     string street1;
     string street2;
     string street3;
     string province;
     string postalcode;
     string city;
     string country;
     string telephone;
     string fax;
     string email;
     string notifyEmail;
     string ssn;
     string ssnType;
     string vat;
     boolean discloseName;
     boolean discloseOrganization;
     boolean discloseEmail;
     boolean discloseAddress;
     boolean discloseTelephone;
     boolean discloseFax;
     boolean discloseIdent;
     boolean discloseVat;
     boolean discloseNotifyEmail;
     Registry::ObjectStatusSeq statusList;
  };

  struct NSSetDetail {
     TID id;
     string handle;
     string roid;
     string registrarHandle;
     string createDate;
     string transferDate;
     string updateDate;
     string createRegistrarHandle;
     string updateRegistrarHandle;
     string authInfo;
     ContactHandleSeq admins;
     DNSHost hosts;
     Registry::ObjectStatusSeq statusList;     
     short reportLevel;
  };

  struct KeySetDetail {
      TID id;
      string handle;
      string roid;
      string registrarHandle;
      string createDate;
      string transferDate;
      string updateDate;
      string createRegistrarHandle;
      string updateRegistrarHandle;
      string authInfo;
      ContactHandleSeq admins;
      DSRecord dsrecords;
      DNSKey dnskeys;
      Registry::ObjectStatusSeq  statusList;
  };

  // Type for list of registrars
  typedef sequence<Registrar> RegistrarList;

  // Type of handle in handle classification
  enum HandleType {
    HT_ENUM_NUMBER, ///< Handle is number (converting)
    HT_ENUM_DOMAIN, ///< Handle is enum domain
    HT_DOMAIN, ///< Handle is non enum domain
    HT_CONTACT, ///< Handle is contact
    HT_NSSET, ///< Handle is nsset
    HT_KEYSET, ///< Handle is keyset
    HT_REGISTRAR, ///< Handle is registrar
    HT_OTHER ///< Invalid handle
  };

  /// Type of detail of handle status
  enum CheckHandleClass {
    CH_UNREGISTRABLE, ///< Handle is outside of register
    CH_UNREGISTRABLE_LONG, ///< Handle is too long
    CH_REGISTRED, ///< Handle is registred
    CH_REGISTRED_PARENT, ///< Handle id registred under super domain
    CH_REGISTRED_CHILD, /// < Handle has registred subdomain
    CH_PROTECTED, //< Handle is in protected period or on blacklist
    CH_FREE ///< Handle is free for registration or has unknown stattus
  };
  
  /// Type for one classification record
  struct CheckHandleType {
    string newHandle; ///< Translated handle
    string conflictHandle; ///< Handle in conflict
    CheckHandleClass handleClass; ///< VÃ½sledek klasifikace handle
    HandleType hType; ///< Type of handle
  };

  /// Return type for checkHandle function
  typedef sequence<CheckHandleType> CheckHandleTypeSeq;

  typedef string SessionIDType;
  
  /// Sequence of domains is used in inverse whois queries
  typedef sequence<DomainDetail> DomainDetails;
  /// Sequence of nssets is used in inverse whois queries
  typedef sequence<NSSetDetail> NSSetDetails;
  /// Sequence of keysets is used in inverse whois queries
  typedef sequence<KeySetDetail> KeySetDetails;
  /// Type of inverse key used for domain search
  enum DomainInvKeyType {
    DIKT_REGISTRANT,
    DIKT_ADMIN,
    DIKT_TEMP,
    DIKT_NSSET,
    DIKT_KEYSET
  };
  /// Type of inverse key used for nsset search
  enum NSSetInvKeyType {
    NIKT_NS,
    NIKT_TECH
  };
  /// Type of inverse key used for keyset search
  enum KeySetInvKeyType {
      KIKT_TECH
  };

  /// forward declaration
  interface Session;

  /// types for ENUM dictionary
  struct TAddress {
    string street1;
    string street2;
    string street3;
    string city;
    string postalcode;
    string province;
    string country;
  };

  struct EnumDictRow {
    string name;
    TAddress address;
    string domain;
  };

  typedef sequence<EnumDictRow> EnumDictList;
  
  //report a problem
  exception ErrorReport 
  {
      string reason;
  };
  
  ///enum type for id-string list 
  struct EnumListItem 
  {
  	unsigned long long id;
  	string name;
  };
  typedef sequence <EnumListItem> EnumList;


  /// interface for administration application
  interface Admin
  {
    /// Exception for internal server error
    exception InternalServerError {};
    /// exception thrown i.e. in case adifd needs to call logd but it's not running
    exception ServiceUnavailable {};
    /// exception thwown in case of failed search
    exception ObjectNotFound {};
    /// exception thrown in case of update failure
    exception UpdateFailed {};
    /// exception thrown when authentification failed
    exception AuthFailed {};
    /// authenticate user against database
    void authenticateUser(in string username, in string password) raises (AuthFailed);
    /// create new session for administrator interface 
    SessionIDType createSession(in string username) raises (AuthFailed);
    /// destroy session
    void destroySession(in string sessionID);
    /// get session
    Session getSession(in SessionIDType sessionID) raises (ObjectNotFound);

    /// return complete list of registrars
    RegistrarList getRegistrars();
    /// return complete list of registrars by access to zone
    RegistrarList getRegistrarsByZone(in string zone);
    /// return one registrar with specified handle
    Registrar getRegistrarByHandle(in string handle) raises (ObjectNotFound);
    /// return registrar detail for specified id
    Registrar getRegistrarById(in TID id) raises (ObjectNotFound);
    /// return contact detail for specified handle
    ContactDetail getContactByHandle(in string handle) raises (ObjectNotFound);
    /// return contact detail for specified id
    ContactDetail getContactById(in TID id) raises (ObjectNotFound);

    /// return nsset detail for specified handel
    NSSetDetail getNSSetByHandle(in string handle) raises (ObjectNotFound);
    /// return nsset detail for specified id
    NSSetDetail getNSSetById(in TID id) raises (ObjectNotFound);

    /// return keyset detail for specified handle
    KeySetDetail getKeySetByHandle(in string handle) raises (ObjectNotFound);
    /// return keyset detail for specified id
    KeySetDetail getKeySetById(in TID id) raises (ObjectNotFound);
    /// return list of keyset details with specified admin contact id
    KeySetDetails getKeySetsByContactId(in TID id, in long limit) raises (ObjectNotFound);
    /// return list of keyset details with specified admin contact handle
    KeySetDetails getKeySetsByContactHandle(in string handle, in long limit) raises (ObjectNotFound);

    /// return domain detail for specified handel
    DomainDetail getDomainByFQDN(in string fqdn) raises (ObjectNotFound);
    /// return domain detail for specified id
    DomainDetail getDomainById(in TID id) raises (ObjectNotFound);
    /// Return list of domain details with specified keyset id
    DomainDetails getDomainsByKeySetId(in TID id, in long limit) raises (ObjectNotFound);
    /// Return list of domain details with specified keyset handle
    DomainDetails getDomainsByKeySetHandle(in string handle, in long limit) raises (ObjectNotFound);

    /// return EPP action detail for specified svTRID
    EPPAction getEPPActionBySvTRID(in string svTRID) raises (ObjectNotFound);
    /// return EPP action detail for specified id
    EPPAction getEPPActionById(in TID id) raises (ObjectNotFound);
    /// return mail detail for specified id
    Mailing::Detail getEmailById(in TID id) 
      raises (ObjectNotFound);
    /// Return count of registred ENUM domains
    long getDomainCount(in string zone);
    /// Return count of signed domains
    long getSignedDomainCount(in string _fqdn);
    /// Return count of numbers described by all registred ENUM domains
    long getEnumNumberCount();
    /// Classify input handle according to registry policy
    void checkHandle(
      in string handle, ///< input handle for classification
      out CheckHandleTypeSeq ch ///< output structure with classification
    );
    /// Return list of epp action types
    Registry::EPPActionTypeSeq getEPPActionTypeList();
    /// Return country code list
    Registry::CountryDescSeq getCountryDescList();
    /// Return default country code
    Registry::CountryCode getDefaultCountry();
    /// Return list with descriptions of available object status for domain
    Registry::ObjectStatusDescSeq getDomainStatusDescList(in string lang);
    /// Return list with descriptions of available object status for contact
    Registry::ObjectStatusDescSeq getContactStatusDescList(in string lang);
    /// Return list with descriptions of available object status for nsset
    Registry::ObjectStatusDescSeq getNSSetStatusDescList(in string lang);
    /// Return list with descriptions of available object status for keyset
    Registry::ObjectStatusDescSeq getKeySetStatusDescList(in string lang);
    /// Return list with descriptions of all available object states
    Registry::ObjectStatusDescSeq getObjectStatusDescList(in string lang) raises (InternalServerError);

    /// Exception for common invalid input data
    exception INVALID_INPUT {};
    /// Exception for unspecified email in ([AUTO|POST]_PIF) request
    exception BAD_EMAIL {};
    /// Exception for bad object id
    exception OBJECT_NOT_FOUND {};
    /// Exception for bad EPP action id in EPP request
    exception ACTION_NOT_FOUND {};
    /// Exception for bad EPP action id in EPP request
    exception SQL_ERROR {};
    /// Exception for unsent emails
    exception MAILER_ERROR {};
    /// Exception for request blocation
    exception REQUEST_BLOCKED {};

    typedef sequence<TID> ObjectIdList;
    TID createPublicRequest(
        in Registry::PublicRequest::Type type,
        in string reason,
        in string emailToAnswer,
        in ObjectIdList objectIds,
        in TID requestId 
	) raises (
	  BAD_EMAIL, OBJECT_NOT_FOUND, ACTION_NOT_FOUND, SQL_ERROR, 
	  INVALID_INPUT, REQUEST_BLOCKED
	);
    /// Process request by sending email with auth_info
    void processPublicRequest(in TID id, in boolean invalid) 
      raises (OBJECT_NOT_FOUND, SQL_ERROR, MAILER_ERROR, REQUEST_BLOCKED);
    typedef sequence<octet> Buffer;
    Buffer getPublicRequestPDF(in TID id, in string lang)
      raises (OBJECT_NOT_FOUND, SQL_ERROR);      

    // disabled in 2.3
    // Invoicing::Invoice getInvoiceById(in TID id);

    /// get domains by registrant, admin or nsset handle
    DomainDetails getDomainsByInverseKey(in string key, in DomainInvKeyType type, in long limit);
    /// get nsset by nameserver or technical contact handle
    NSSetDetails getNSSetsByInverseKey(in string key, in NSSetInvKeyType type, in long limit);
    /// get keyset by technical contact handle
    KeySetDetails getKeySetsByInverseKey(in string key, in KeySetInvKeyType type, in long limit);
    
    /// return credit for registrer and zone
    Money getCreditByZone(in string registrar, in TID zone)
      raises (SQL_ERROR);
    /// generate letter with warning about registration expiration
    void generateLetters();
    /// manually insert domain into the zone
    boolean setInZoneStatus(in TID domainId);

    unsigned long long countEnumDomainsByRegistrant(in string name, in boolean by_person, in boolean by_org) raises (InternalServerError);
    EnumDictList getEnumDomainsByRegistrant(in string name, in boolean by_person, in boolean by_org, in long offset, in long limit) raises (InternalServerError);
    EnumDictList getEnumDomainsRecentEntries(in long count) raises (InternalServerError);


    Registry::Registrar::Certification::Manager getCertificationManager();
    Registry::Registrar::Group::Manager getGroupManager();
    
    EnumList getBankAccounts()//list of bank accounts
      raises (ErrorReport);

 };

  /// Main interface for registrar session

  interface BankingInvoicing {
      enum OperationType {
          OT_CREATE,
          OT_RENEW
      };
/*
      boolean addBankAccount(in string zoneName, in string accountNumber,
              in string accountName, in string bankCode);
      void archiveInvoices(in boolean send);
*/
      boolean pairPaymentRegistrarId(in unsigned long long paymentId,
              in unsigned long long registrarId);
      boolean pairPaymentRegistrarHandle(in  unsigned long long paymentId,
              in string registrarHandle);
      boolean setPaymentType(in unsigned long long payment_id, in short payment_type);
/*
      boolean addPrefix(in string zoneName, in long type, in long year,
              in unsigned long long prefix);
      boolean pairInvoices();
      boolean createCreditInvoice(in TID zone, in TID registrar,
              in Money price, in date taxdate, in timestamp crdate);
      boolean factoring(in TID zone, in TID registrar,
              in date todate, in date taxdate);
      boolean addPrice(in TID zone, in OperationType operation,
              in timestamp validFrom, in timestamp validTo,
              in Money price, in long period);
*/
  };
  interface Session {
    Registry::PageTable getPageTable(in FilterType type) raises (ccReg::Admin::ServiceUnavailable);
    any getDetail(in FilterType type, in TID id) raises (ccReg::Admin::ObjectNotFound, ccReg::Admin::ServiceUnavailable, Registry::SqlQueryTimeout);
    BankingInvoicing getBankingInvoicing();
    User getUser();

    TID updateRegistrar(in Registrar registrar_data) raises (ccReg::Admin::UpdateFailed, ccReg::Admin::ObjectNotFound);
    void setHistory(in boolean history);
  };
  
/*
  interface EnumDict {
    EnumDictList getEnumDomainsByRegistrant(in string handle, in boolean by_name, in boolean by_org);
    EnumDictList getEnumDomainsRecentEntries(in long count);
  };
*/

};

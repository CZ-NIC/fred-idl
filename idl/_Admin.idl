#include "Filters.idl"
#include "_Registry.idl"
// TEMP: XXX forward declaration of PageTable
//       for returning new type from Session::getPageTable()
//       method (will be removed when using only Registry module)
module Registry {
  interface PageTable;

  module Registrar
  {
      module Certification
      {
          interface Manager;
      };
      module Group
      {
          interface Manager;
      };
  };
};

module ccReg {
  
  
  /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  ///          Filter management
  /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


  /// Filter for common registry object
  interface RegObjectFilter : Registry::FilterBase {
    /// Those made by specific registrar
    attribute TID registrar;    
    /// Those made by specific registrar byt handle
    attribute string registrarHandle;
    /// Those created by specific registrar
    attribute TID createRegistrar;    
    /// Those created by specific registrar byt handle
    attribute string createRegistrarHandle;
    /// Those updated by specific registrar
    attribute TID updateRegistrar;    
    /// Those updated by specific registrar byt handle
    attribute string updateRegistrarHandle;
    /// Interval of crDate
    attribute DateInterval crDate;
    /// Interval of trDate
    attribute DateInterval trDate;
    /// Interval of upDate
    attribute DateInterval upDate;
    /// Search in status - 'and' operator between values
    attribute Registry::ObjectStatusSeq status;
  };

  /// Filter for EPPActions
  interface EPPActionsFilter : Registry::FilterBase {
    /// Result classification type
    enum ResultType {
      RT_FAIL, ///< result >= 2000 or no result code at all
      RT_OK    ///< result < 2000
    };
    /// Those made by specific registrar
    attribute TID registrar;
    /// Those made by specific registrar byt handle
    attribute string registrarHandle;
    /// Those of specific type
    attribute Registry::EPPActionType type;
    /// Those refefing to object with this handle
    attribute string handle;
    /// Those having substring in xml
    attribute string xml;
    /// Those with this result code
    attribute short result;
    /// Those having proper result classification
    attribute ResultType resultClass;
    /// Those processed at this date interval
    attribute DateTimeInterval time;
    /// Those with specified clTRID
    attribute string clTRID;
    /// Those with specified svTRID
    attribute string svTRID;
  };

  typedef string Money;
  
  /// Access structure
  struct EPPAccess {
    string password; ///< epp login password
    string md5Cert; ///< md5 of certificate
  };
  
  /// List of access structures
  typedef sequence<EPPAccess> EPPAccessSeq;
  
  ///Zone access
  struct ZoneAccess
  {
      ccReg::TID id; ///record id
      string name; ///zone name
      DateType fromDate;  ///start of registrar's access to zone
      DateType toDate; ///end of registrar's access to zone
  };//struct ZoneAccess

  /// List of zone structures
  typedef sequence<ZoneAccess> ZoneAccessSeq;

  /// Registrar detail structure
  struct Registrar {
    TID id; ///< registrar ID
    string ico;
    string dic;
    string varSymb;
    boolean vat;
    string handle; ///< registrar identification
    string name; ///< registrar name
    string organization; ///< organization name
    string street1; ///< address part 1
    string street2; ///< address part 2
    string street3; ///< address part 3
    string city; ///< city of registrar headquaters
    string stateorprovince; ///< address part
    string postalcode; ///< address part
    Registry::CountryCode country; ///< country code
    string telephone; ///< phne number
    string fax; ///< fax number
    string email; ///< contact email
    string url; ///< URL
    Money credit; ///< actual credit
    EPPAccessSeq access; ///< list of epp access data
    ZoneAccessSeq zones; ///< list of active registrar's zones
    boolean hidden; ///< hidden in PIF
  };

  struct EPPAction {
    TID id; ///< id of action
    string time; /// < processing time
    string xml; ///< xml of request
    string xml_out; ///< xml of response
    string type; ///< typename of request
    string objectHandle; ///< handle of major object
    string registrarHandle; ///< handle of registrar processiong request
    short result; ///< result code
    string clTRID; ///< token provided by registrar
    string svTRID; ///< token attached by server
  };
 

  typedef sequence<string> ContactHandleSeq;
  struct DomainDetail {
     TID id;
     string fqdn;
     string roid;
     string registrarHandle;
     string createDate;
     string transferDate;
     string updateDate;
     string createRegistrarHandle;
     string updateRegistrarHandle;
     string authInfo;
     string registrantHandle;
     string expirationDate;
     string valExDate;
     boolean publish; 
     string nssetHandle;
     string keysetHandle;
     ContactHandleSeq admins;
     ContactHandleSeq temps;
     Registry::ObjectStatusSeq statusList;
  };

  struct ContactDetail {
     TID id;
     string handle;
     string roid;
     string registrarHandle;
     string createDate;
     string transferDate;
     string updateDate;
     string createRegistrarHandle;
     string updateRegistrarHandle;
     string authInfo;
     string name;
     string organization;
     string street1;
     string street2;
     string street3;
     string province;
     string postalcode;
     string city;
     string country;
     string telephone;
     string fax;
     string email;
     string notifyEmail;
     string ssn;
     string ssnType;
     string vat;
     boolean discloseName;
     boolean discloseOrganization;
     boolean discloseEmail;
     boolean discloseAddress;
     boolean discloseTelephone;
     boolean discloseFax;
     boolean discloseIdent;
     boolean discloseVat;
     boolean discloseNotifyEmail;
     Registry::ObjectStatusSeq statusList;
  };

  struct NSSetDetail {
     TID id;
     string handle;
     string roid;
     string registrarHandle;
     string createDate;
     string transferDate;
     string updateDate;
     string createRegistrarHandle;
     string updateRegistrarHandle;
     string authInfo;
     ContactHandleSeq admins;
     DNSHost hosts;
     Registry::ObjectStatusSeq statusList;     
     short reportLevel;
  };

  struct KeySetDetail {
      TID id;
      string handle;
      string roid;
      string registrarHandle;
      string createDate;
      string transferDate;
      string updateDate;
      string createRegistrarHandle;
      string updateRegistrarHandle;
      string authInfo;
      ContactHandleSeq admins;
      DSRecord dsrecords;
      DNSKey dnskeys;
      Registry::ObjectStatusSeq  statusList;
  };

  // Type for list of registrars
  typedef sequence<Registrar> RegistrarList;

  // Type of handle in handle classification
  enum HandleType {
    HT_ENUM_NUMBER, ///< Handle is number (converting)
    HT_ENUM_DOMAIN, ///< Handle is enum domain
    HT_DOMAIN, ///< Handle is non enum domain
    HT_CONTACT, ///< Handle is contact
    HT_NSSET, ///< Handle is nsset
    HT_KEYSET, ///< Handle is keyset
    HT_REGISTRAR, ///< Handle is registrar
    HT_OTHER ///< Invalid handle
  };

  /// Type of detail of handle status
  enum CheckHandleClass {
    CH_UNREGISTRABLE, ///< Handle is outside of register
    CH_UNREGISTRABLE_LONG, ///< Handle is too long
    CH_REGISTRED, ///< Handle is registred
    CH_REGISTRED_PARENT, ///< Handle id registred under super domain
    CH_REGISTRED_CHILD, /// < Handle has registred subdomain
    CH_PROTECTED, //< Handle is in protected period or on blacklist
    CH_FREE ///< Handle is free for registration or has unknown stattus
  };
  
  /// Type for one classification record
  struct CheckHandleType {
    string newHandle; ///< Translated handle
    string conflictHandle; ///< Handle in conflict
    CheckHandleClass handleClass; ///< VÃ½sledek klasifikace handle
    HandleType hType; ///< Type of handle
  };

  /// Return type for checkHandle function
  typedef sequence<CheckHandleType> CheckHandleTypeSeq;

  typedef string SessionIDType;
  
  /// Sequence of domains is used in inverse whois queries
  typedef sequence<DomainDetail> DomainDetails;
  /// Sequence of nssets is used in inverse whois queries
  typedef sequence<NSSetDetail> NSSetDetails;
  /// Sequence of keysets is used in inverse whois queries
  typedef sequence<KeySetDetail> KeySetDetails;
  /// Type of inverse key used for domain search
  enum DomainInvKeyType {
    DIKT_REGISTRANT,
    DIKT_ADMIN,
    DIKT_TEMP,
    DIKT_NSSET,
    DIKT_KEYSET
  };
  /// Type of inverse key used for nsset search
  enum NSSetInvKeyType {
    NIKT_NS,
    NIKT_TECH
  };
  /// Type of inverse key used for keyset search
  enum KeySetInvKeyType {
      KIKT_TECH
  };

  /// forward declaration
  interface Session;

  /// types for ENUM dictionary
  struct TAddress {
    string street1;
    string street2;
    string street3;
    string city;
    string postalcode;
    string province;
    string country;
  };

  struct EnumDictRow {
    string name;
    TAddress address;
    string domain;
  };

  typedef sequence<EnumDictRow> EnumDictList;
  
  //report a problem
  exception ErrorReport 
  {
      string reason;
  };
  
  ///enum type for id-string list 
  struct EnumListItem 
  {
  	unsigned long long id;
  	string name;
  };
  typedef sequence <EnumListItem> EnumList;


  /// interface for administration application
  interface Admin
  {
    /// Exception for internal server error
    exception InternalServerError {};
    /// exception thrown i.e. in case adifd needs to call logd but it's not running
    exception ServiceUnavailable {};
    /// exception thwown in case of failed search
    exception ObjectNotFound {};
    /// exception thrown in case of update failure
    exception UpdateFailed {};
    /// exception thrown when authentification failed
    exception AuthFailed {};
    /// authenticate user against database
    void authenticateUser(in string username, in string password) raises (AuthFailed);
    /// create new session for administrator interface 
    SessionIDType createSession(in string username) raises (AuthFailed);
    /// destroy session
    void destroySession(in string sessionID);
    /// get session
    Session getSession(in SessionIDType sessionID) raises (ObjectNotFound);

    /// return complete list of registrars
    RegistrarList getRegistrars();
    /// return complete list of registrars by access to zone
    RegistrarList getRegistrarsByZone(in string zone);
    /// return one registrar with specified handle
    Registrar getRegistrarByHandle(in string handle) raises (ObjectNotFound);
    /// return registrar detail for specified id
    Registrar getRegistrarById(in TID id) raises (ObjectNotFound);
    /// return contact detail for specified handle
    ContactDetail getContactByHandle(in string handle) raises (ObjectNotFound);
    /// return contact detail for specified id
    ContactDetail getContactById(in TID id) raises (ObjectNotFound);

    /// return nsset detail for specified handel
    NSSetDetail getNSSetByHandle(in string handle) raises (ObjectNotFound);
    /// return nsset detail for specified id
    NSSetDetail getNSSetById(in TID id) raises (ObjectNotFound);

    /// return keyset detail for specified handle
    KeySetDetail getKeySetByHandle(in string handle) raises (ObjectNotFound);
    /// return keyset detail for specified id
    KeySetDetail getKeySetById(in TID id) raises (ObjectNotFound);
    /// return list of keyset details with specified admin contact id
    KeySetDetails getKeySetsByContactId(in TID id, in long limit) raises (ObjectNotFound);
    /// return list of keyset details with specified admin contact handle
    KeySetDetails getKeySetsByContactHandle(in string handle, in long limit) raises (ObjectNotFound);

    /// return domain detail for specified handel
    DomainDetail getDomainByFQDN(in string fqdn) raises (ObjectNotFound);
    /// return domain detail for specified id
    DomainDetail getDomainById(in TID id) raises (ObjectNotFound);
    /// Return list of domain details with specified keyset id
    DomainDetails getDomainsByKeySetId(in TID id, in long limit) raises (ObjectNotFound);
    /// Return list of domain details with specified keyset handle
    DomainDetails getDomainsByKeySetHandle(in string handle, in long limit) raises (ObjectNotFound);

    /// return EPP action detail for specified svTRID
    EPPAction getEPPActionBySvTRID(in string svTRID) raises (ObjectNotFound);
    /// return EPP action detail for specified id
    EPPAction getEPPActionById(in TID id) raises (ObjectNotFound);
    /// Return count of registred ENUM domains
    long getDomainCount(in string zone);
    /// Return count of signed domains
    long getSignedDomainCount(in string _fqdn);
    /// Return count of numbers described by all registred ENUM domains
    long getEnumNumberCount();
    /// Classify input handle according to registry policy
    void checkHandle(
      in string handle, ///< input handle for classification
      out CheckHandleTypeSeq ch ///< output structure with classification
    );
    /// Return list of epp action types
    Registry::EPPActionTypeSeq getEPPActionTypeList();
    /// Return country code list
    Registry::CountryDescSeq getCountryDescList();
    /// Return default country code
    Registry::CountryCode getDefaultCountry();
    /// Return list with descriptions of available object status for domain
    Registry::ObjectStatusDescSeq getDomainStatusDescList(in string lang);
    /// Return list with descriptions of available object status for contact
    Registry::ObjectStatusDescSeq getContactStatusDescList(in string lang);
    /// Return list with descriptions of available object status for nsset
    Registry::ObjectStatusDescSeq getNSSetStatusDescList(in string lang);
    /// Return list with descriptions of available object status for keyset
    Registry::ObjectStatusDescSeq getKeySetStatusDescList(in string lang);
    /// Return list with descriptions of all available object states
    Registry::ObjectStatusDescSeq getObjectStatusDescList(in string lang) raises (InternalServerError);

    /// Exception for common invalid input data
    exception INVALID_INPUT {};
    /// Exception for unspecified email in ([AUTO|POST]_PIF) request
    exception BAD_EMAIL {};
    /// Exception for bad object id
    exception OBJECT_NOT_FOUND {};
    /// Exception for bad EPP action id in EPP request
    exception ACTION_NOT_FOUND {};
    /// Exception for bad EPP action id in EPP request
    exception SQL_ERROR {};
    /// Exception for unsent emails
    exception MAILER_ERROR {};
    /// Exception for request blocation
    exception REQUEST_BLOCKED {};

    typedef sequence<TID> ObjectIdList;
    TID createPublicRequest(
        in Registry::PublicRequest::Type type,
        in string reason,
        in string emailToAnswer,
        in ObjectIdList objectIds,
        in TID requestId 
	) raises (
	  BAD_EMAIL, OBJECT_NOT_FOUND, ACTION_NOT_FOUND, SQL_ERROR, 
	  INVALID_INPUT, REQUEST_BLOCKED
	);
    /// Process request by sending email with auth_info
    void processPublicRequest(in TID id, in boolean invalid) 
      raises (OBJECT_NOT_FOUND, SQL_ERROR, MAILER_ERROR, REQUEST_BLOCKED);
    typedef sequence<octet> Buffer;
    Buffer getPublicRequestPDF(in TID id, in string lang)
      raises (OBJECT_NOT_FOUND, SQL_ERROR);      

    // disabled in 2.3
    // Invoicing::Invoice getInvoiceById(in TID id);

    /// get domains by registrant, admin or nsset handle
    DomainDetails getDomainsByInverseKey(in string key, in DomainInvKeyType type, in long limit);
    /// get nsset by nameserver or technical contact handle
    NSSetDetails getNSSetsByInverseKey(in string key, in NSSetInvKeyType type, in long limit);
    /// get keyset by technical contact handle
    KeySetDetails getKeySetsByInverseKey(in string key, in KeySetInvKeyType type, in long limit);
    
    /// return credit for registrer and zone
    Money getCreditByZone(in string registrar, in TID zone)
      raises (SQL_ERROR);
    /// generate letter with warning about registration expiration
    void generateLetters();
    /// manually insert domain into the zone
    boolean setInZoneStatus(in TID domainId);

    unsigned long long countEnumDomainsByRegistrant(in string name, in boolean by_person, in boolean by_org) raises (InternalServerError);
    EnumDictList getEnumDomainsByRegistrant(in string name, in boolean by_person, in boolean by_org, in long offset, in long limit) raises (InternalServerError);
    EnumDictList getEnumDomainsRecentEntries(in long count) raises (InternalServerError);


    Registry::Registrar::Certification::Manager getCertificationManager();
    Registry::Registrar::Group::Manager getGroupManager();
    
    EnumList getBankAccounts()//list of bank accounts
      raises (ErrorReport);

 };

  /// Main interface for registrar session

  interface BankingInvoicing {
      enum OperationType {
          OT_CREATE,
          OT_RENEW
      };
/*
      boolean addBankAccount(in string zoneName, in string accountNumber,
              in string accountName, in string bankCode);
      void archiveInvoices(in boolean send);
*/
      boolean pairPaymentRegistrarId(in unsigned long long paymentId,
              in unsigned long long registrarId);
      boolean pairPaymentRegistrarHandle(in  unsigned long long paymentId,
              in string registrarHandle);
      boolean setPaymentType(in unsigned long long payment_id, in short payment_type);
/*
      boolean addPrefix(in string zoneName, in long type, in long year,
              in unsigned long long prefix);
      boolean pairInvoices();
      boolean createCreditInvoice(in TID zone, in TID registrar,
              in Money price, in date taxdate, in timestamp crdate);
      boolean factoring(in TID zone, in TID registrar,
              in date todate, in date taxdate);
      boolean addPrice(in TID zone, in OperationType operation,
              in timestamp validFrom, in timestamp validTo,
              in Money price, in long period);
*/
  };
  interface Session {
    Registry::PageTable getPageTable(in FilterType type) raises (ccReg::Admin::ServiceUnavailable);
    any getDetail(in FilterType type, in TID id) raises (ccReg::Admin::ObjectNotFound, ccReg::Admin::ServiceUnavailable, Registry::SqlQueryTimeout);
    BankingInvoicing getBankingInvoicing();
    Registry::User getUser();

    TID updateRegistrar(in Registrar registrar_data) raises (ccReg::Admin::UpdateFailed, ccReg::Admin::ObjectNotFound);
    void setHistory(in boolean history);
  };
  
/*
  interface EnumDict {
    EnumDictList getEnumDomainsByRegistrant(in string handle, in boolean by_name, in boolean by_org);
    EnumDictList getEnumDomainsRecentEntries(in long count);
  };
*/

};
